**并发**：

系统有多个任务同时工作

**高并发**：

系统支持同时处理很多的请求，一般单体服务超过1000QPS就可以算上高并发。

**需要考虑**：

最好是能够从业务上面差分，通过一些中间件消化掉高并发的需求。之前一次对接数据对接，之前的同事对接采用的一个专门的服务来做，要这么做，基本上QPS要达到2000左右。后面我调整了方案，在整体里面加入了kafka，kafka并发性好，可以堆积大量的数据，能够做到很好的削峰填谷的作用，然后再定制组件，即能够确保数据不丢失，又可以动态增加服务数量，通过集群的方式提高并发量，系统整体的复杂度也降低了，上线以来没有出现大问题。

当然有的业务场景无法避免高并发，也是需要考虑如下的情况：

- 网络带宽 ， 特别是视频类的高并发业务，千兆的网卡，一般实际能够用到也就600M左右，不能忽视。
- 缓存，以空间换时间，数据缓存是常用的手段，将常用的数据缓存在内存，速度可以极大提升。说到缓存，最好使用原生类型，一些时间Calendar，Date尽量使用long，或者业务无关的情况下直接去掉。之前感觉这些不重要，但是数据多，特别是权限相关的，也能积少成多，一次oom，一个用户对象，就达到400M，在写入Memcache直接挂掉
- OOM，处理高并发数据的时候，通常都会用到线程池，一定要根据业务场景，创建自己的线程池，使用有界限的队列，使用数量合适的线程数量，这个方面的坑也不少。
- 死锁，高并发最容易出现死锁的情况，所以在使用的锁的地方，要使用小颗粒的锁，有超时机制，避免循环死锁。
- 数据库，并发的数据量大的情况下，需要考虑分表分库，读写分离
- MQ，实时性要求不高的业务，最好过一下MQ，能搞达到削峰填谷，堆积数据，为后续系统升级等做好基础

